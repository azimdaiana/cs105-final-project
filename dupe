from typing import List from Logic import precondition from random import randint, choice from PIL import Image import json def load_map(fileName: str) -> List[List[int]]: """ converts info stored in a txt file into a list that will be used as a maze for a user :param fileName: takes in a txt file that has a maze written in :return: returns the maze in a list of lists """ file = open(fileName, "r") firstLine = file.readline() #reads the dimensions # print(firstLine) rows, cols = map(int, firstLine.split("x")) #splits the first line using the x to parse the dimensions and converts to ints grid = [] for i in range(rows): line = file.readline().strip() row = [] for char in line: row.append(int(char)) #converts the row into ints and creates a list(row) of int grid.append(row) #appends the rows into the matrix file.close() return grid def randomMaze(rows:int, cols:int) -> List[List[int]]: """ generates a random maze based on the inputs of dimensions, the maze is characterized by 0 = walls, 1 = walking path, 3 = battles/enemies, 2 = end state :param rows: # of rows in a maze :param cols: # of columns in a maze :return: returns a matrix/maze stored in a list of lists """ grid: List[List[int]] = [] #empty map for i in range(rows): #create an empty map of only 0s (walls) grid.append([0] * cols) #starting points currentCol = 0 currentRow = 0 grid[currentRow][currentCol] = 1 #the start path = [(currentRow, currentCol)] #initiating a path #creating a path through the map while currentRow < rows - 1: direction = choice(["down", "left", "right"]) #randomly choose a direction if direction == "down" and currentRow + 1 < rows: currentRow += 1 elif direction == "left" and currentCol > 0: currentCol -= 1 elif direction == "right" and currentCol < cols - 1: currentCol += 1 if grid[currentRow][currentCol] == 0: grid[currentRow][currentCol] = 1 #updates the 0 at the location to a 1 path.append([currentRow, currentCol]) #saves the path to the goal grid[currentRow][currentCol] = 2 #indicate the end goal #adding battles on the path if cols > 5: #randomizes the number of battles depending on the size of the map numBattles = randint(4, cols+1) else: numBattles = randint(2, cols+1) battlePosPoss = path[:-1]  # possible enemy locations for i in range(numBattles): if battlePosPoss: battlePos = choice(battlePosPoss) #randomized battle position battleRow = battlePos[0] battleCol = battlePos[1] grid[battleRow][battleCol] = 3 #position of the battle battlePosPoss.remove(battlePos) #removes the possibility of a repeat grid[0][0] = 1 return grid def print_map(map): player_map = [] for i in map: f = [] for l in i: if l == 0 or l ==7: f.append(l) else: f.append(0) player_map.append(f) return player_map def canGoEast(y: int, grid) -> bool: global player_x, player_y if y < 0 or y >= len(grid[0]): print(f"\nMoving in this direction would be out of bound. Please try a different direction.") return False if grid[player_x][y] == 0: return False else: return True def canGoWest(y: int, grid) -> bool: global player_x, player_y if y < 0 or y >= len(grid[0]): print(f"\nMoving in this direction would be out of bound. Please try a different direction.") return False if grid[player_x][y] == 0: return False else: return True def canGoNorth(x: int, grid) -> bool: global player_x, player_y if x < 0 or x >= len(grid): print(f"\nMoving in this direction would be out of bound. Please try a different direction.") return False if grid[x][player_y] == 0: return False else: return True def canGoSouth(x: int, grid) -> bool: global player_x, player_y if x < 0 or x >= len(grid): print(f"\nMoving in this direction would be out of bound. Please try a different direction.") return False if grid[x][player_y] == 0: return False else: return True def goEast(y: int, progMap): global player_y, player_x for i in range(abs(player_y - y)): progMap[player_x][player_y + i] = 7 player_y = y def goWest(y: int, progMap): global player_y, player_x for i in range(abs(player_y - y)): progMap[player_x][player_y - i] = 7 player_y = y def goNorth(x: int, progMap): global player_y, player_x for i in range(abs(player_x - x)): progMap[player_x - i][player_y] = 7 player_x = x def goSouth(x: int, progMap): global player_y, player_x for i in range(abs(player_x - x)): progMap[player_x + i][player_y] = 7 player_x = x player_x = 0 player_y = 0 def getCurrentLocation() -> tuple: global player_x, player_y return (player_x, player_y) def updateCurrentLocation(newPlayer_x, newPlayer_y): global player_x, player_y player_x, player_y = newPlayer_x, newPlayer_y return (player_x, player_y) def resetCurrentLocation(): global player_x, player_y player_x, player_y = 0,0 return(player_x, player_y) def setLocation(x: int, player_x:int, y: int, player_y:int, grid, progMap)-> bool: if precondition(x == player_x or y == player_y) == False: print(f"You can only move in a straight line horizontally or vertically!") return False if x > player_x: if canGoSouth(x, grid): goSouth(x, progMap) return True else: return False elif x < player_x: if canGoNorth(x, grid): goNorth(x, progMap) return True else: return False elif y < player_y: if canGoWest(y, grid): goWest(y, progMap) return True else: return False elif y > player_y: if canGoEast(y, grid): goEast(y, progMap) return True else: return False def goalReached(grid): if grid[player_x][player_y] == 2: print(f"You found the exit and have escaped this castle level.\n") open('lastGameSaved.json', 'w').close()  # clears the last saved game # code for the 4 functions below is a modified version of https://github.com/Kernel-rb/Image2ASCII def resizeImg(image, newWidth): """ :param image: path file :param newWidth: int value :return: resized img to fit the terminal """ width, height = image.size ratio = height / width newHeight = int(newWidth * ratio * 0.55) #height adjusted for terminal return image.resize((newWidth, newHeight)) def pixelToGrayscale(image): """ :param image: img path :return: converts the img into grayscale """ return image.convert("L")  # "L" mode for grayscale def pixelToAscii(image): """ :param image: img path :return: map each pixel in the img to an ASCII char """ ASCIICHAR = "@%#*+=-:. " pixels = image.getdata() asciiStr = "" for pixel_value in pixels: index = pixel_value * (len(ASCIICHAR) - 1) // 255 asciiStr += ASCIICHAR[index] return asciiStr def graphic(image, newWidth): try: image = Image.open(image) except: print("unable to open image") return # Convert to grayscale and ASCII art grayscaleImg= pixelToGrayscale(resizeImg(image, newWidth)) newImgPixels = pixelToAscii(grayscaleImg) asciiImg = "\n".join(newImgPixels[i:i + newWidth] for i in range(0, len(newImgPixels), newWidth)) return asciiImg  # Print the ASCII art to the console def generate_problem() -> str: operations: list = ["+", "-", "*"] first_num = randint(1, 12) operation = choice(operations) second_num = randint(1, 12) if operation == "+": solution = first_num + second_num elif operation == "-": solution = first_num - second_num else: solution = first_num * second_num return str(first_num) + " " + operation + " " + str(second_num), int(solution) def guard_found(): # if grid[player_y][player_x] == 3: problem, solution = generate_problem() print(graphic("guard.jpg", 25)) print("You have encountered a guard. If you can correctly answer this problem for him, you may pass \n" "through. If not, you will be sent to the dungeon... \nHere is your problem: " + problem) answer = input("Answer: ") if int(answer) == solution: print("Yay! You are free to continue!") return True else: print("Off to the dungeon. You have failed the game.") print(graphic("images.jpeg", 60)) return False def savingGame(player_x, player_y, grid, progMap): prevPlay = { "lastLoc": [player_x, player_y], "grid": grid, "progMap": progMap, } with open('lastGameSaved.json', 'w') as lastGame: json.dump(prevPlay, lastGame) print("Game has been saved successfully. Come back soon to continue where you left off!") def loadSavedGame(): with open("lastGameSaved.json", "r") as lastGame: prevPlay = json.load(lastGame) return prevPlay["lastLoc"], prevPlay["grid"], prevPlay["progMap"]

import blessed import time from utilities import load_map, print_map, randomMaze, getCurrentLocation, setLocation, guard_found, generate_problem, loadSavedGame, savingGame, goalReached, resetCurrentLocation, updateCurrentLocation term = blessed.Terminal() currentMapNum = 1 progressMade = False grid = None s = None def selectMap(): """ starts the game by allowing player to input which map they would like. Uses load_map to set 'grid' to desired map :return: grid, progMap, the user's current location coordinates """ global player_x, player_y, currentMapNum, progressMade, grid, s print( "Choose a number on how you would like to play the game: \n" "1. Progress through pre-built maps (map1 -> map5)\n" "2. Generate a random map\n" "3. Load a saved game\n") s = input("Your choice: ") if s == "1": progressMade = True currentMapNum = 1 grid = load_map(f"map{currentMapNum}.txt") elif s == "2": try: print("The value for rows and columns must be greater than 1!") r = int(input('How many rows will your grid have? ')) c = int(input('How many columns will your grid have? ')) grid = randomMaze(r, c) except ValueError: print("Invalid input for grid size\n") return selectMap() elif s == "3": try: loc, grid, progMap = loadSavedGame() player_x, player_y = loc print("Your last game has been uploaded!\n" f"Current location: ({player_y+1}, {player_x+1})\n") return grid, progMap, player_x, player_y except (FileNotFoundError, ValueError): print("No saved game found. Please choose a new map.\n") return selectMap() else: print("Invalid choice. Please enter 1, 2, or 3.") return selectMap() progMap = print_map(grid) player_x, player_y = getCurrentLocation() print(f'\nYour selected map has the following dimensions: {len(grid)}x{len(grid[0])}.') print( 'You are currently trapped in a castle and must find your way out. To move, you must choose a direction (north, south, west, or east) to move a unit.\n' 'However, beware of the guards positioned throughout the castle. They might challenge you to a battle!\n\n' "Find a path through the castle using the commands! 7s will represent the places you have been and Y is your current location.\n" ) return grid, progMap, player_x, player_y def draw_map(progMap, player_x, player_y): """ :param progMap: map displayed to the user :param player_x:  row coord :param player_y: column coord :return: visually comprehensible maze with user's position as a green Y """ for y, row in enumerate(progMap): line = "" for x, cell in enumerate(row): if x == player_x and y == player_y: line += term.on_black + term.green + term.reverse + "Y" + term.normal else: line += str(cell) print(term.move(y + 2, 2) + line) def UI_run(): global grid, progMap, currentMapNum, progressMade, player_y, player_x, s with term.fullscreen(), term.cbreak(), term.hidden_cursor(): win = False #continuous input dependent on if the player wins or not while win == False: print("This is your current map:") if s == "3": draw_map(progMap, player_x, player_y) else: draw_map(progMap, player_y, player_x) i = input(term.move(len(grid) + 6, 2) + "> What would you like to do? (move/save): ").lower() if 'move' in i: direction = input(term.move(len(grid) + 6, 2) + "> Which direction would you like to go? (north/south/east/west): ").lower() x, y = player_x, player_y if direction == "east": distMoved = setLocation(x, player_x, y + 1, player_y, grid, progMap) elif direction == "west": distMoved = setLocation(x, player_x, y - 1, player_y, grid, progMap) elif direction == "south": distMoved = setLocation(x + 1, player_x, y, player_y, grid, progMap) elif direction == "north": distMoved = setLocation(x - 1, player_x, y, player_y, grid, progMap) else: print("\nInvalid direction. Please try again.") continue if s == "3": player_x, player_y = updateCurrentLocation(player_x, player_y) else: player_x, player_y = getCurrentLocation() if distMoved == False: print(f"\nYou cannot move there.") elif grid[player_x][player_y] == 3: if guard_found(): print(f"\nMoved a unit {direction}.") else: win = True progressMade = False elif grid[player_x][player_y] == 2: draw_map(progMap, player_y, player_x) goalReached(grid) win = True else: print(f"\nMoved a unit {direction}.") elif "save" in i: savingGame(player_x, player_y, grid, progMap) return elif "print" in i: #cheat key print(grid) if progressMade and currentMapNum < 5: currentMapNum += 1 print(f"You have leveled up to map {currentMapNum}. ") grid = load_map(f"map{currentMapNum}.txt") progMap = print_map(grid) player_x, player_y = 0, 0 resetCurrentLocation() UI_run() elif progressMade and currentMapNum == 5: print("Congrats! You have completed all of the pre-built levels.") if __name__ == "__main__": print("Welcome to Medieval Math Mayhem, a text-based math adventure game!\n") startTime = time.time() print(f"Your start time is {time.ctime(startTime)}") grid, progMap, player_x, player_y = selectMap() UI_run() endTime = time.time() print(f"\nYour end time is {time.ctime(endTime)}") timePlayed = round(endTime - startTime, 2) mins = int(timePlayed // 60) secs = int(timePlayed % 60) if mins > 0: print(f"It has taken you {mins} minutes {secs} seconds to play the game.") else: print(f"It has taken you {secs} seconds to play the game.") print("\nThanks for playing!\nRestart to play again.")
